Вопрос 1
Мы обсудили алгоритм линейного поиска, работающий за O(n) и алгоритм бинарного поиска, работающий за O(log n). Значит ли это, что на любых входных данных бинарный поиск делает меньше операций, чем линейный поиск? Приведите пример при n = 100, где линейный поиск найдет первую 1 быстрее бинарного

Ответ 1
Нет

«О»-нотация описывает асимптотическую временную сложность. Качество оценки алгоритма растёт с увеличением n и количества экспериментов. Таким образом, существуют частные случаи, при которых менее оптимизированные алгоритмы завершают работу быстрее более оптимизированных.

Пример:
1 1 1 ... 1 1 1
Линейный поиск, 1 итерация. Бинарный поиск, 7 итераций (2^6 <= 100 <= 2^7).

Вопрос 2
Мы хотим протестировать, что вы умеете писать бинарный поиск. Считывание массива из n чисел работает за O(n). Получается, если давать тесты на ввод, то бинпоиск не будет "слабым звеном" алгоритма, и даже если вы напишете линейный поиск, то асимптотика не изменится (O(n) на чтение данных через input() + O(n) на линейный поиск = O(n)).

Мы планируем дать один массив размера n и попросить на нем сделать q разных поисков, чтобы получить от вас "составную" асимптотику O(n + q log n). Какое нам сделать q, чтобы поиск заметно перевешивал считывание данных? Только так мы сможем замерить, что ваше решение делает поиск быстрее, чем за O(n)

Ответ 2
O(n)     | O(n + log n)
O(q * n) | O(n + q * log n)

q = n

O(n * n) | O(n + n * log n)
O(n * n) | O(n * (log n + 1))
O(n * n) | O(n * log n)

O(n * n) >> [заметно больше, чем] O(n * log n)

Вопрос 3
Мы придумали на лекции, как делать бинпоиск, если известны и левая и правая границы (то есть область, где мы ищем смену 0 на 1). А что делать, если границы области заранее неизвестны?

Например, кто-то загадал натуральное число n, которое может быть каким угодно большим (проигнорируем вопрос того, влезет ли это число в память компьютера), а мы все равно хотим найти границы и сделать бинпоиск вопросами "число n меньше чем x?".

Предложите идею, как найти хотя бы одно число, большее n, за O(log(n)) - после этого мы сможем запустить бинпоиск. Вопрос со звездочкой и неправильный ответ / отсутствие не штрафуется.

Ответ 3
С математической точки зрения, если выбор любого числа от 1 до бесконечности равновероятен, то вероятность, что "число n меньше x", стремится к нулю.

T l = 0, r = 1;
while (n > r) {
    r <<= 1; // 1, 2, 4, 8 ... степени двойки
    l = r;
} // O(log n)

while (l + 1 < r) {
    T m = (l + r) / 2;
     
    if (m < n)
        l = m;
    else 
        r = m;
} // O(log (n) - 1)

cout << r;

----
O(log (n) + log (n) - 1)
O(2 log n)
O(log n)