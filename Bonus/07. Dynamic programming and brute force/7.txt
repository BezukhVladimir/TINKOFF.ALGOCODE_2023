Вопрос 1
Мы на лекции обсудили формулу mask & (mask - 1), которая дает для маски ее копию без последней единицы. Поисследуем другие операции на масках:

Что сделает mask1 | mask2? В ответе расскажите, что произойдет с множествами, которые были заданы масками. Дополнительно, если интересно, можно подумать, как реализованы O_CREAT и O_WRONLY в функции open на C, если их нужно объединять через | (пример тут https://linuxhint.com/posix-open-function-c-programming/), это не будет оцениваться

Что сделает mask | (mask + 1)?

Ответ 1
1)
| — оператор объединения множеств.
Результатом будет маска, включающая все единицы, которые были хотя бы в одной из исходных масок. Например, с помощью таких масок можно хранить комбинированные права доступа, разрешенные каждой из масок в отдельности.

2)
Результатом будет маска для нечётного числа в диапазоне от (mask, 2^(mask.bitsize)).
Исключение, если mask = 2^(mask.bitsize) - 1,
тогда результатом будет 2^(mask.bitsize + 1) - 1

Вопрос 2
Нам для подсчета суммы в подмножестве нужно уметь по степени двойки понять ее логарифм. 1 -> 0, 2->1, 4->2, 8->3, 16->4, и так далее. Предложите как предподсчитать такую информацию заранее, и потом вычислять нужное значение  во время пересчета за O(1)

Ответ 2
В двоичной системе счисления можно работать со степенями двойки через биты.
Например, 16 — 10000. Для степени двойки количество значащих нулей в двоичной записи обозначает log_2 этого числа.

Для 32 битного натурального числа:
31 - __builtin_clz(x), где __builtin_clz(x) возвращает количество незначащих нулей

Например, 15 — 00000000 00000000 00000000 00001111
31 - 28 = 3, ближайшая степень двойки, которая меньше исходного числа