Вопрос 1
Мы обсудили skip-list как структуру, в которой мы заранее сделали log n уровней, после чего узлы при добавлении сами решают, на скольки уровнях они окажутся добавлены. Но вообще-то, пока в списке 10 элементов, поддерживать 20 уровней смысла нет. Предложите в общих чертах, как можно изменить скиплист, чтобы количество уровней динамически менялось и соответствовало логарифму от текущего количества элементов.

Ответ 1
Каждый раз, когда количество элементов достигает степени двойки, добавлять новый слой "снизу"

1

1
2

1
2 3

1   
2 3
4 

1    
2 3 
4 5 6 7
8

Вопрос 2
Ситуация - вам нужно сделать очередь. Вы знаете, что в очереди никогда не будет больше, чем K элементов. На лекции мы обсудили, как сделать очередь на массиве, но этого может не хватить - пусть программа с очередью будет работать три месяца подряд, обрабатывая запросы на добавления и удаления. Если делать сдвиги указателей (или очередь на списках), нам придется делать новые аллокации - это плохо. Если делать очередь на двух стеках, то у нас будет амортизированный алгоритм - это плохо. Хочется выделить O(K) памяти один раз, и построить над ними очередь, которая за О(1) отвечает на каждый запрос. Что делать? 

Ответ 2
Берём очередь на массиве.

Выделяем один раз O(K) памяти.

Храним поля head и tail с индексами соответствующих элементов.

Этого достаточно, чтобы методы size, empty, push и pop выполнялись за O(1)
